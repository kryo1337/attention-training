<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>pureReaction</title>
    <link rel="preload" href="reaction.wasm" as="fetch" type="application/wasm" crossorigin fetchpriority="high" />
    <style>
      html, body { height: 100%; margin: 0; background: #111; color: #ddd; font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, 'Courier New', monospace; }
      #wrap { display: grid; place-items: center; height: 100%; gap: 12px; position: relative; }
      canvas { image-rendering: pixelated; background: #000; box-shadow: 0 0 0 2px #222; touch-action: none; max-width: 100%; max-height: 100%; }
      #overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; z-index: 20; }
      #panel { background: rgba(0,0,0,0.8); color: #fff; padding: 12px 16px; border: 1px solid #333; border-radius: 8px; min-width: 240px; text-align: center; }
      #panel h2 { margin: 0 0 8px 0; font-size: 16px; font-weight: 600; }
      #panel .nums { display: grid; gap: 6px; margin: 8px 0; font-size: 14px; }
      #panel button { margin-top: 8px; padding: 6px 10px; background: #222; color: #ddd; border: 1px solid #333; border-radius: 6px; }
      #hint { opacity: 0.8; font-size: 14px; }
      button { padding: 6px 10px; background: #222; color: #ddd; border: 1px solid #333; border-radius: 6px; }
      #controls { display: flex; flex-direction: column; gap: 8px; align-items: center; color: #ccc; font-size: 14px; }
      #controls label { opacity: 0.85; }
      #controls select { padding: 4px 6px; background: #1a1a1a; color: #ddd; border: 1px solid #333; border-radius: 4px; }
      #controls input { width: 72px; padding: 4px 6px; background: #1a1a1a; color: #ddd; border: 1px solid #333; border-radius: 4px; }
      #header-icons { position: absolute; top: 16px; right: 16px; display: flex; gap: 12px; z-index: 10; }
      #header-icons a { color: #666; transition: color 0.2s, transform 0.2s; display: flex; align-items: center; justify-content: center; }
      #header-icons a:hover { color: #ddd; transform: scale(1.1); }
      #footer { position: absolute; bottom: 12px; left: 0; width: 100%; text-align: center; font-size: 12px; color: #444; z-index: 10; pointer-events: none; display: flex; flex-direction: column; gap: 4px; }
      #footer a { color: #666; text-decoration: none; pointer-events: auto; transition: color 0.2s; }
      #footer a:hover { color: #ddd; }
    </style>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WP1BV7L2Y5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-WP1BV7L2Y5');
    </script>
  </head>
  <body>
    <div id="wrap">
      <div id="header-icons">
        <a href="https://buymeacoffee.com/kryo" target="_blank" aria-label="Buy Me a Coffee">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M20 3H4v10c0 2.21 1.79 4 4 4h6c2.21 0 4-1.79 4-4v-3h2c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 5h-2V5h2v3M4 19h16v2H4z"/></svg>
        </a>
        <a href="https://github.com/kryo1337/pure-reaction" target="_blank" aria-label="GitHub">
          <svg width="24" height="24" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
        </a>
      </div>
      <canvas id="canvas" width="480" height="270"></canvas>
      <div id="controls">
        <span id="hint">left click/space to react, r to reset</span>
        <label for="trial-count">trials per session:</label>
        <select id="trial-count">
          <option value="5">5</option>
          <option value="10">10</option>
          <option value="25">25</option>
          <option value="50">50</option>
          <option value="custom">Customâ€¦</option>
        </select>
        <input id="trial-custom" type="number" min="1" step="1" value="5" aria-label="Custom trials" hidden />
      </div>
      <div id="overlay"><div id="panel">
        <h2 id="resultsTitle">Results (5 trials)</h2>
        <div class="nums">
          <div id="avg">Average: -</div>
          <div id="med">Median: -</div>
          <div id="fast">Fastest: -</div>
        </div>
        <button id="reset">Reset</button>
      </div></div>
      <div id="footer">
        <div>developed by <a href="https://kryo.dev" target="_blank">kryo</a></div>
        <div>&copy; 2025 pureReaction</div>
      </div>
    </div>
    <script>
      const canvas = document.getElementById('canvas');
      let offscreen;
      let worker;
      const overlay = document.getElementById('overlay');
      const avgEl = document.getElementById('avg');
      const medEl = document.getElementById('med');
      const fastEl = document.getElementById('fast');
      const resetBtn = document.getElementById('reset');
      const trialSelect = document.getElementById('trial-count');
      const trialCustom = document.getElementById('trial-custom');
      const resultsTitle = document.getElementById('resultsTitle');

      function resizeCanvas() {
        const w = window.innerWidth - 24;
        const h = Math.min(window.innerHeight - 120, 540);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      async function loadWasm() {
        if (WebAssembly.instantiateStreaming) {
          const { instance } = await WebAssembly.instantiateStreaming(fetch('reaction.wasm'), {});
          return instance;
        } else {
          const response = await fetch('reaction.wasm');
          const bytes = await response.arrayBuffer();
          const { instance } = await WebAssembly.instantiate(bytes, {});
          return instance;
        }
      }

      const wasmPromise = loadWasm();

      (async () => {
        const wasm = await wasmPromise;
        const exp = wasm.exports;
        const rect = canvas.getBoundingClientRect();
        let W = Math.floor(rect.width) || 480;
        let H = Math.floor(rect.height) || 270;
        canvas.width = W; canvas.height = H;
        exp.init(W, H);
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            const rect = canvas.getBoundingClientRect();
            W = Math.floor(rect.width);
            H = Math.floor(rect.height);
            
            if (useWorker) {
              worker.postMessage({ type: 'resize', size: { W, H }, state: exp.get_state(), ms: Math.round(exp.get_last_reaction_ms()) });
            } else {
              canvas.width = W;
              canvas.height = H;
              // Context needs to be restored after resize clears it
              if (ctx) {
                ctx.imageSmoothingEnabled = false;
                ctx.font = '24px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
              }
              // Force repaint by invalidating state
              prevState = -1;
            }
          }, 50);
        });

        function seedRng() {
          if (exp.seed_rng && crypto.getRandomValues) {
            const buf = new Uint32Array(2);
            crypto.getRandomValues(buf);
            const seed = (BigInt(buf[0]) << 32n) | BigInt(buf[1]);
            exp.seed_rng(seed);
          }
        }
        seedRng();

        let useWorker = false;
        let ctx = canvas.getContext('2d', { 
          alpha: false, 
          desynchronized: true 
        });
        ctx.imageSmoothingEnabled = false;
        ctx.fillStyle = '#0040c0';
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#ffffff';
        ctx.font = '24px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Click to begin', W >> 1, H >> 1);

        try {
          offscreen = canvas.transferControlToOffscreen();
          worker = new Worker('worker.js', { type: 'module' });
          worker.postMessage({ type: 'init', canvas: offscreen, size: { W, H } }, [offscreen]);
          worker.postMessage({ type: 'paint', state: exp.get_state(), repaint: true, ms: 0 });
          useWorker = true;
          ctx = null;
        } catch (err) {
          useWorker = false;
        }

        let last = performance.now();
        let prevState = -1;
        let readyAt = 0;
        let clickedAt = 0;
        const trials = [];
        let sessionOver = false;
        let trialGoal = parseInt(trialSelect.value, 10);
        let lastCustomValue = Math.max(1, parseInt(trialCustom.value, 10) || 5);

        if (Number.isNaN(trialGoal)) {
          trialGoal = lastCustomValue;
          trialSelect.value = 'custom';
          trialCustom.hidden = false;
        } else {
          trialCustom.hidden = trialSelect.value !== 'custom';
        }

        const updateResultsTitle = () => {
          resultsTitle.textContent = 'Results (' + trialGoal + ' trials)';
        };
        updateResultsTitle();

        function showOverlay(a, m, f) {
          avgEl.textContent = 'Average: ' + Math.round(a) + ' ms';
          medEl.textContent = 'Median: ' + Math.round(m) + ' ms';
          fastEl.textContent = 'Fastest: ' + Math.round(f) + ' ms';
          overlay.style.display = 'flex';
          sessionOver = true;
        }

        function hideOverlay() {
          overlay.style.display = 'none';
        }

        function computeStats(arr) {
          if (arr.length === 0) return { avg: 0, med: 0, fast: 0 };
          const sum = arr.reduce((a, b) => a + b, 0);
          const avg = sum / arr.length;
          const sorted = arr.slice().sort((a,b) => a-b);
          const mid = sorted.length >> 1;
          const med = (sorted.length % 2) ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;
          const fast = sorted[0];
          return { avg, med, fast };
        }
        function paint(ctx, W, H, s, repaint, ms) {
          if (repaint) {
            if (s === 0) ctx.fillStyle = '#0040c0';
            else if (s === 1 || s === 4) ctx.fillStyle = '#c02030';
            else if (s === 2) ctx.fillStyle = '#18a040';
            else ctx.fillStyle = '#8020c0';
            ctx.fillRect(0, 0, W, H);
          }

          switch (s) {
            case 3: {
              ctx.fillStyle = '#ffcc00';
              ctx.font = '40px monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(ms + ' ms', W >> 1, H >> 1);
              ctx.font = '20px monospace';
              ctx.fillStyle = '#ffffff';
              ctx.fillText('Click to begin next trial', W >> 1, (H >> 1) + 40);
              break;
            }
            case 0:
              ctx.fillStyle = '#ffffff';
              ctx.font = '24px monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('Click to begin', W >> 1, H >> 1);
              break;
            case 4:
              ctx.fillStyle = '#ffffff';
              ctx.font = '28px monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('False start! Click to restart trial', W >> 1, H >> 1);
              break;
          }
        }
        function frame(now) {
          const dt = now - last; last = now;
          exp.update(dt);

          // 0=Idle(blue), 1=Waiting(red), 2=Ready(green), 3=Measured(purple), 4=FalseStart (red)
          const s = exp.get_state();
          if (s === 2 && prevState !== 2) {
            readyAt = now;
            clickedAt = 0;
          }

          if (!sessionOver && s === 3 && prevState !== 3) {
            const measured = Math.round(clickedAt > 0 ? clickedAt - readyAt : exp.get_last_reaction_ms());
            trials.push(measured);
            if (trials.length === trialGoal) {
              const { avg, med, fast } = computeStats(trials);
              showOverlay(avg, med, fast);
            }
          }

          const repaint = s !== prevState;
          if (repaint) prevState = s;

          const ms = Math.round(clickedAt > 0 ? clickedAt - readyAt : exp.get_last_reaction_ms());
          if (useWorker) {
            worker.postMessage({ type: 'paint', state: s, repaint, ms });
          } else {
            paint(ctx, W, H, s, repaint, ms);
          }

          requestAnimationFrame(frame);
        }

        let pointerDown = false;
        const resetSession = () => {
          pointerDown = false;
          trials.length = 0;
          sessionOver = false;
          clickedAt = 0;
          readyAt = 0;
          prevState = -1;
          last = performance.now();
          hideOverlay();
          exp.on_action(0);
          exp.reset();
          seedRng();
          if (useWorker) {
            worker.postMessage({ type: 'paint', state: exp.get_state(), repaint: true, ms: 0 });
          } else if (ctx) {
            ctx.fillStyle = '#0040c0';
            ctx.fillRect(0, 0, W, H);
            ctx.fillStyle = '#ffffff';
            ctx.font = '24px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Click to begin', W >> 1, H >> 1);
          }
          updateResultsTitle();
        };
        const press = (ts) => {
          if (sessionOver || pointerDown) return;
          pointerDown = true;
          const s = exp.get_state();
          if (s === 2 && readyAt > 0) {
            clickedAt = (typeof ts === 'number' && ts > 0) ? ts : performance.now();
            if (navigator.getPredictedEvents) {
              try {
                const predicted = navigator.getPredictedEvents();
                if (predicted.length > 0) {
                  for (let i = 0; i < predicted.length; i++) {
                    if (predicted[i].type === 'pointerdown') {
                      clickedAt = predicted[i].timeStamp;
                      break;
                    }
                  }
                }
              } catch (e) { /* ignore */ }
            }
          }
          exp.on_action(1);
        };
        const release = () => { 
          if (sessionOver) return; 
          pointerDown = false;
          exp.on_action(0); 
        };
        
        window.addEventListener('keydown', (e) => { 
          if (e.code === 'Space') { 
            e.preventDefault(); 
            press(e.timeStamp); 
          } else if (e.code === 'KeyR') {
            e.preventDefault();
            resetSession();
          }
        }, { capture: true, passive: false });
        window.addEventListener('keyup', (e) => { 
          if (e.code === 'Space') { 
            e.preventDefault(); 
            release(); 
          } 
        }, { capture: true, passive: false });
        
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        canvas.addEventListener('pointerdown', (e) => { 
          if (e.button === 0) {
            e.preventDefault();
            canvas.setPointerCapture(e.pointerId);
            press(e.timeStamp);
          }
        }, { capture: true, passive: false });
        
        let lastRawPointer = null;
        canvas.addEventListener('pointerrawupdate', (e) => {
          lastRawPointer = e.timeStamp;
          if (!pointerDown && exp.get_state() === 2 && e.pressure > 0) {
            press(e.timeStamp);
          }
        }, { capture: true, passive: true });
        
        window.addEventListener('pointerup', (e) => { 
          if (e.button === 0) {
            e.preventDefault();
            if (canvas.hasPointerCapture(e.pointerId)) {
              canvas.releasePointerCapture(e.pointerId);
            }
            release();
          }
        }, { capture: true, passive: false });
        resetBtn.addEventListener('click', () => {
          resetSession();
        });

        trialSelect.addEventListener('change', () => {
          const sel = trialSelect.value;
          if (sel === 'custom') {
            trialCustom.hidden = false;
            const next = Math.max(1, parseInt(trialCustom.value, 10) || lastCustomValue);
            lastCustomValue = next;
            trialGoal = next;
            updateResultsTitle();
            resetSession();
          } else {
            trialCustom.hidden = true;
            const next = parseInt(sel, 10);
            if (Number.isNaN(next)) return;
            trialGoal = next;
            updateResultsTitle();
            resetSession();
          }
        });

        trialCustom.addEventListener('change', () => {
          if (trialCustom.hidden) return;
          const parsed = Math.max(1, parseInt(trialCustom.value, 10) || lastCustomValue);
          lastCustomValue = parsed;
          trialGoal = parsed;
          updateResultsTitle();
          resetSession();
        });

        trialCustom.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            trialCustom.dispatchEvent(new Event('change'));
          }
        });

        requestAnimationFrame(frame);
      })();
    </script>
  </body>
  </html>

