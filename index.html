<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Reaction Time</title>
    <link rel="preload" href="reaction.wasm" as="fetch" type="application/wasm" crossorigin fetchpriority="high" />
    <style>
      html, body { height: 100%; margin: 0; background: #111; color: #ddd; font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, 'Courier New', monospace; }
      #wrap { display: grid; place-items: center; height: 100%; gap: 12px; position: relative; }
      canvas { image-rendering: pixelated; background: #000; box-shadow: 0 0 0 2px #222; touch-action: none; }
      #overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; }
      #panel { background: rgba(0,0,0,0.8); color: #fff; padding: 12px 16px; border: 1px solid #333; border-radius: 8px; min-width: 240px; text-align: center; }
      #panel h2 { margin: 0 0 8px 0; font-size: 16px; font-weight: 600; }
      #panel .nums { display: grid; gap: 6px; margin: 8px 0; font-size: 14px; }
      #panel button { margin-top: 8px; padding: 6px 10px; background: #222; color: #ddd; border: 1px solid #333; border-radius: 6px; }
      #hint { opacity: 0.8; font-size: 14px; }
      button { padding: 6px 10px; background: #222; color: #ddd; border: 1px solid #333; border-radius: 6px; }
      #controls { display: flex; flex-direction: column; gap: 8px; align-items: center; color: #ccc; font-size: 14px; }
      #controls label { opacity: 0.85; }
      #controls select { padding: 4px 6px; background: #1a1a1a; color: #ddd; border: 1px solid #333; border-radius: 4px; }
      #controls input { width: 72px; padding: 4px 6px; background: #1a1a1a; color: #ddd; border: 1px solid #333; border-radius: 4px; }
    </style>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WP1BV7L2Y5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-WP1BV7L2Y5');
    </script>
  </head>
  <body>
    <div id="wrap">
      <canvas id="canvas" width="480" height="270"></canvas>
      <div id="controls">
        <span id="hint">left click/space to react, r to reset</span>
        <label for="trial-count">trials per session:</label>
        <select id="trial-count">
          <option value="5">5</option>
          <option value="10">10</option>
          <option value="25">25</option>
          <option value="50">50</option>
          <option value="custom">Customâ€¦</option>
        </select>
        <input id="trial-custom" type="number" min="1" step="1" value="5" aria-label="Custom trials" hidden />
      </div>
      <div id="overlay"><div id="panel">
        <h2 id="resultsTitle">Results (5 trials)</h2>
        <div class="nums">
          <div id="avg">Average: -</div>
          <div id="med">Median: -</div>
          <div id="fast">Fastest: -</div>
        </div>
        <button id="reset">Reset</button>
      </div></div>
    </div>
    <script>
      const canvas = document.getElementById('canvas');
      let offscreen;
      let worker;
      const overlay = document.getElementById('overlay');
      const avgEl = document.getElementById('avg');
      const medEl = document.getElementById('med');
      const fastEl = document.getElementById('fast');
      const resetBtn = document.getElementById('reset');
      const trialSelect = document.getElementById('trial-count');
      const trialCustom = document.getElementById('trial-custom');
      const resultsTitle = document.getElementById('resultsTitle');

      function resizeCanvas() {
        const w = Math.min(window.innerWidth - 24, 960);
        const h = Math.min(window.innerHeight - 120, 540);
        const aspect = 16/9;
        let tw = w, th = Math.round(w / aspect);
        if (th > h) { th = h; tw = Math.round(h * aspect); }
        canvas.style.width = tw + 'px';
        canvas.style.height = th + 'px';
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      async function loadWasm() {
        if (WebAssembly.instantiateStreaming) {
          const { instance } = await WebAssembly.instantiateStreaming(fetch('reaction.wasm'), {});
          return instance;
        } else {
          const response = await fetch('reaction.wasm');
          const bytes = await response.arrayBuffer();
          const { instance } = await WebAssembly.instantiate(bytes, {});
          return instance;
        }
      }

      const wasmPromise = loadWasm();

      (async () => {
        const wasm = await wasmPromise;
        const exp = wasm.exports;
        const W = 480, H = 270;
        canvas.width = W; canvas.height = H;
        exp.init(W, H);
        
        if (exp.seed_rng && crypto.getRandomValues) {
          const buf = new Uint32Array(2);
          crypto.getRandomValues(buf);
          const seed = (BigInt(buf[0]) << 32n) | BigInt(buf[1]);
          exp.seed_rng(seed);
        }

        let useWorker = false;
        let ctx = canvas.getContext('2d', { 
          alpha: false, 
          desynchronized: true 
        });
        ctx.imageSmoothingEnabled = false;
        ctx.fillStyle = '#0040c0';
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#ffffff';
        ctx.font = '16px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Click to begin', W >> 1, H >> 1);

        try {
          offscreen = canvas.transferControlToOffscreen();
          worker = new Worker('worker.js', { type: 'module' });
          worker.postMessage({ type: 'init', canvas: offscreen, size: { W, H } }, [offscreen]);
          worker.postMessage({ type: 'paint', state: exp.get_state(), repaint: true, ms: 0 });
          useWorker = true;
          ctx = null;
        } catch (err) {
          useWorker = false;
        }

        let last = performance.now();
        let prevState = -1;
        let readyAt = 0;
        let clickedAt = 0;
        const trials = [];
        let sessionOver = false;
        let trialGoal = parseInt(trialSelect.value, 10);
        let lastCustomValue = Math.max(1, parseInt(trialCustom.value, 10) || 5);

        if (Number.isNaN(trialGoal)) {
          trialGoal = lastCustomValue;
          trialSelect.value = 'custom';
          trialCustom.hidden = false;
        } else {
          trialCustom.hidden = trialSelect.value !== 'custom';
        }

        const updateResultsTitle = () => {
          resultsTitle.textContent = 'Results (' + trialGoal + ' trials)';
        };
        updateResultsTitle();

        function showOverlay(a, m, f) {
          avgEl.textContent = 'Average: ' + Math.round(a) + ' ms';
          medEl.textContent = 'Median: ' + Math.round(m) + ' ms';
          fastEl.textContent = 'Fastest: ' + Math.round(f) + ' ms';
          overlay.style.display = 'flex';
          sessionOver = true;
        }

        function hideOverlay() {
          overlay.style.display = 'none';
        }

        function computeStats(arr) {
          if (arr.length === 0) return { avg: 0, med: 0, fast: 0 };
          const sum = arr.reduce((a, b) => a + b, 0);
          const avg = sum / arr.length;
          const sorted = arr.slice().sort((a,b) => a-b);
          const mid = sorted.length >> 1;
          const med = (sorted.length % 2) ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;
          const fast = sorted[0];
          return { avg, med, fast };
        }
        function frame(now) {
          const dt = now - last; last = now;
          exp.update(dt);

          // 0=Idle(blue), 1=Waiting(red), 2=Ready(green), 3=Measured(purple), 4=FalseStart (red)
          const s = exp.get_state();
          if (s === 2 && prevState !== 2) {
            readyAt = now;
            clickedAt = 0;
          }

          if (!sessionOver && s === 3 && prevState !== 3) {
            const measured = Math.round(clickedAt > 0 ? clickedAt - readyAt : exp.get_last_reaction_ms());
            trials.push(measured);
            if (trials.length === trialGoal) {
              const { avg, med, fast } = computeStats(trials);
              showOverlay(avg, med, fast);
            }
          }

          const repaint = s !== prevState;
          if (repaint) prevState = s;

          const ms = Math.round(clickedAt > 0 ? clickedAt - readyAt : exp.get_last_reaction_ms());
          if (useWorker) {
            worker.postMessage({ type: 'paint', state: s, repaint, ms });
          } else {
            if (repaint) {
              if (s === 0) ctx.fillStyle = '#0040c0';
              else if (s === 1 || s === 4) ctx.fillStyle = '#c02030';
              else if (s === 2) ctx.fillStyle = '#18a040';
              else ctx.fillStyle = '#8020c0';
              ctx.fillRect(0, 0, W, H);
            }
            if (s === 3) {
              ctx.fillStyle = '#ffcc00';
              ctx.font = '24px monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(ms + ' ms', W >> 1, H >> 1);
              ctx.font = '14px monospace';
              ctx.fillStyle = '#ffffff';
              ctx.fillText('Click to begin next trial', W >> 1, (H >> 1) + 28);
            }
            if (s === 0) {
              ctx.fillStyle = '#ffffff';
              ctx.font = '16px monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('Click to begin', W >> 1, H >> 1);
            }
            if (s === 4) {
              ctx.fillStyle = '#ffffff';
              ctx.font = '18px monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('False start! Click to restart trial', W >> 1, H >> 1);
            }
          }

          requestAnimationFrame(frame);
        }

        let pointerDown = false;
        const resetSession = () => {
          pointerDown = false;
          trials.length = 0;
          sessionOver = false;
          clickedAt = 0;
          readyAt = 0;
          prevState = -1;
          last = performance.now();
          hideOverlay();
          exp.on_action(0);
          exp.reset();
          if (useWorker) {
            worker.postMessage({ type: 'paint', state: exp.get_state(), repaint: true, ms: 0 });
          } else if (ctx) {
            ctx.fillStyle = '#0040c0';
            ctx.fillRect(0, 0, W, H);
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Click to begin', W >> 1, H >> 1);
          }
          updateResultsTitle();
        };
        const press = (ts) => {
          if (sessionOver || pointerDown) return;
          pointerDown = true;
          const s = exp.get_state();
          if (s === 2 && readyAt > 0) {
            clickedAt = (typeof ts === 'number' && ts > 0) ? ts : performance.now();
            if (navigator.getPredictedEvents) {
              try {
                const predicted = navigator.getPredictedEvents();
                if (predicted.length > 0) {
                  for (let i = 0; i < predicted.length; i++) {
                    if (predicted[i].type === 'pointerdown') {
                      clickedAt = predicted[i].timeStamp;
                      break;
                    }
                  }
                }
              } catch (e) { /* ignore */ }
            }
          }
          exp.on_action(1);
        };
        const release = () => { 
          if (sessionOver) return; 
          pointerDown = false;
          exp.on_action(0); 
        };
        
        window.addEventListener('keydown', (e) => { 
          if (e.code === 'Space') { 
            e.preventDefault(); 
            press(e.timeStamp); 
          } else if (e.code === 'KeyR') {
            e.preventDefault();
            resetSession();
          }
        }, { capture: true, passive: false });
        window.addEventListener('keyup', (e) => { 
          if (e.code === 'Space') { 
            e.preventDefault(); 
            release(); 
          } 
        }, { capture: true, passive: false });
        
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        canvas.addEventListener('pointerdown', (e) => { 
          if (e.button === 0) {
            e.preventDefault();
            canvas.setPointerCapture(e.pointerId);
            press(e.timeStamp);
          }
        }, { capture: true, passive: false });
        
        let lastRawPointer = null;
        canvas.addEventListener('pointerrawupdate', (e) => {
          lastRawPointer = e.timeStamp;
          if (!pointerDown && exp.get_state() === 2 && e.pressure > 0) {
            press(e.timeStamp);
          }
        }, { capture: true, passive: true });
        
        window.addEventListener('pointerup', (e) => { 
          if (e.button === 0) {
            e.preventDefault();
            if (canvas.hasPointerCapture(e.pointerId)) {
              canvas.releasePointerCapture(e.pointerId);
            }
            release();
          }
        }, { capture: true, passive: false });
        resetBtn.addEventListener('click', () => {
          resetSession();
        });

        trialSelect.addEventListener('change', () => {
          const sel = trialSelect.value;
          if (sel === 'custom') {
            trialCustom.hidden = false;
            const next = Math.max(1, parseInt(trialCustom.value, 10) || lastCustomValue);
            lastCustomValue = next;
            trialGoal = next;
            updateResultsTitle();
            resetSession();
          } else {
            trialCustom.hidden = true;
            const next = parseInt(sel, 10);
            if (Number.isNaN(next)) return;
            trialGoal = next;
            updateResultsTitle();
            resetSession();
          }
        });

        trialCustom.addEventListener('change', () => {
          if (trialCustom.hidden) return;
          const parsed = Math.max(1, parseInt(trialCustom.value, 10) || lastCustomValue);
          lastCustomValue = parsed;
          trialGoal = parsed;
          updateResultsTitle();
          resetSession();
        });

        trialCustom.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            trialCustom.dispatchEvent(new Event('change'));
          }
        });

        requestAnimationFrame(frame);
      })();
    </script>
  </body>
  </html>

